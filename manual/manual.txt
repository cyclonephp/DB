The DB library is
<ul>
 <li> the low-level database abstraction layer of the CyclonePHP
		framework.</li>
 <li> It provides a DBMS-independent way of accessing and
		manipulating databases.</li>
 <li> Similar to Kohana's Database module.</li>
 <li> The back-end layer for JORK</li>
 <li> Can be used as a stand-alone module</li>
 <li> Supports transactions and prepared statements</li>
 <li> Comes with a minimal active record implementation</li>
</ul>

The library provides an internal DSL (can be used via method call chains) to
create objects representing SQL queries and statements. These objects are meant
to be a DBMS-independent representation of the database operation. These query
objects are compiled and executed by DBMS-specific adapters provided by the library,
and the query result fetching is also wrapped by the adapters. This way the database
operations can be handled in the application in a DBMS-independent manner. This
way the application is more easily portable between different database systems.
The adapters will hide the differences between SQL dialects and between the PHP API-s
to access the different databases.
 
 @section db-gettingstarted Getting started with the DB library
 
 Let's create a sample database in MySQL:
 
 @code
 CREATE DATABASE simpledb;
	
	GRANT ALL ON simpledb.* TO 'simpledb'@'localhost' IDENTIFIED BY 'simpledb';
	
	CREATE TABLE users (
		id INT PRIMARY KEY AUTO_INCREMENT,
		name VARCHAR(32) NOT NULL
	);
	@endcode
 
 Let's set up the database connection in <tt> app/config/db/default.php </tt> :
 
 @code
 <?php

	return array(
		'adapter' => 'mysqli',
		'connection' => array(
			'username' => 'simpledb',
			'password' => 'simpledb',
			'database' => 'simpledb',
			'host' => 'localhost',
		)
	);
 @endcode
 
 So we told DB that we will have a database connection called
  'default', and we are going to use the MySQLi adapter for that.
 It means that the MySQLi extension will be used to communicate
 with the database.
	
 With the DB lib you can manage multiple connections at the same time.
 The only thing you have to do you have to tell the module what connection
 do you want to use every time you execute an SQL query. If you
 don't then the default connection will be 'default'.
 More about it later.

<em>Note: all examples below in the library manual will assume that the
<code>\cyclone</code> namespace is aliased to <code>cy</code></em>.

 
 @section db-datamanip Data manipulation
 
 In this section we will cover the steps of building data manipulating SQL statements.
 
 @subsection db-insert INSERT
 
 We are going to load some data into the database, so let's look
 at the INSERT statements:
 @code
 $id = cy\DB::insert('users')->values(array('name' => 'user 01'))->exec();
 @endcode
 
 This piece of code creates an INSERT statement and executes it
 on the 'default' database connection. If you have wanted to use - for 
 example - a connection set up in <tt> application/config/db/legacy.php </tt>
 then you would call @code exec('legacy') @endcode at the end of the code.
 
 In the above example the @c $id variable stores the primary key of the
 last inserted row.
 
 <em>Note: retrieving the ID of the last inserted row goes quickly for
 MySQL, but it can cause some performance overhead for other DBMSs.
 You can disable the insert ID retrieval by passing FALSE in the
 second parameter of the exec() call. In this case the return value 
 will be NULL.</em>
 
 You can insert multiple rows in the same INSERT statement this way:
 @code
 cy\DB::insert('users')->values(array('name' => 'user 02')
 , array('name' => 'user 03'))->exec();
 @endcode
 
 So, the values() method has variable length parameter list, where
 every parameter should be a column-name =\> value associative array.
 
 @subsection db-update UPDATE
 
 The syntax of UPDATE statements is very similar to INSERTs.
 Example:
 
 @code
 $id = 1;  // we are going to update the row with id = 1
 $row_count = cy\DB::update('users')->values(array('name' => 'user 01 updated'))
		->where('id', '=', cy\DB::esc($id))->exec();
 @endcode
 
 We pass the table name to the @c update() call, then key-value pairs
 to the @c values() call, where keys should be column names and values
 should be the values to be updated. Then we create a @c WHERE condition.
 Note that the ID - the parameter of the query is in a @c cy\DB::esc() call.
 This method call should be used always when you want to pass
 any user-entered data to your queries, this way it will be escaped
 to avoid SQL injection. Furthermore, if you don't use @c cy\DB::esc()
 then most times the query execution will result into an SQL error.
 
 More about @c WHERE conditions later. Note that you also have to call
 @c exec() for @c UPDATE statements too, optionally by passing the database
 connection name.
 
 The @c exec() call for @c UPDATE statements return the number of affected
 rows by the SQL @c UPDATE (it's stored in the @c $row_count) variable
 in this case).
 
 @subsection db-delete DELETE
 
 The syntax of DELETE statements is very similar. Example:
 @code
 $id = 1;
 $row_count = cy\DB::delete('users')->where('id', '=', cy\DB::esc($id))->exec();
 @endcode
 
 The return value is the number of rows deleted.
 
 @section db-select SELECT
 
 SELECT queries can be much more complicated then other SQL statements. In
  this chapter we are going to look at the most important guidelines of
  building SELECTs, but we won't cover each query builder methods in detail.
  For further information please look at the API docs.
  
  So let's get started with a simple query:
  @code
  cy\DB::select()->from('users')->exec();
  @endcode
  
  This will generate the SQL <tt>SELECT * FROM `users`</tt> and will execute
  it on the default database connection.
  
  To specify the columns to be selected pass them to the <tt>select()</tt> method:
  @code
  cy\DB::select('id', 'name')->from('users')->exec();
  @endcode
  
  Generated SQL:
  @code
  SELECT `id`, `name` from `users`
  @endcode
  
  <em>Note that in the generated SQL the column and table names are escaped, 
  so you can use SQL keywords as table or columns names, but it's not recommended</em>
  
  Let's add a @c WHERE clause:
  @code
  $id = 2;
  cy\DB::select()->from('users')->where('id', '=', cy\DB::esc($id))->exec();
  @endcode
  
  As it has already been mentioned in the UPDATE section, you have to put your
  parameters into a @c cy\DB::esc() call.
  
  If you select from multiple tables then you have to qualify your table names, 
  as you normally should do in SQL:
  @code
  cy\DB::select('users.id', 'users.name', 'posts.text')->from('users', 'posts')->exec();
  @endcode
  
  Generated SQL:
  @code
  SELECT `users`.`id`, `users`.`name`, `posts`.`text` FROM `users`, `posts`
  @endcode
  
  
  When you have more than one tables in your @c FROM and @c JOIN clauses,
  you will likely want to add an alias name for them. If you want to add an
  alias name to a table, you have to use it in <tt>array('table_name', 'alias')</tt>
  format:
  @code
  cy\DB::select('u.id', 'u.name', 'p.text')->from(array('users', 'u')
  		, array('posts', 'p'))->exec();
  @endcode
  
  If you want to give an alias name to your column in the @c SELECT clause, then
  you also have to use the same format:
  @code
  cy\DB::select(array('u.id', 'userid')
  		, array('u.name', 'username')
  		, 'p.text')->from(array('users', 'u'), array('posts', 'p'))->exec();
  @endcode
  
  You can build the JOIN clause of the query using the @c join() and @c on()
  builder methods. Example:
  @code
  cy\DB::select(array('u.id', 'userid')
  		, array('u.name', 'username')
  		, 'posts.text')->from(array('users', 'u'))
  		->join('posts')->on('u.id', '=', 'post.author_fk')->exec();
  @endcode
  
  In the 2th parameter of the @c join() call you can specify what kind of
  join you want to perform (LEFT, RIGHT, INNER, whatever). The default
  value is LEFT. The DB library won't care about the contents of the 2th parameter,
  so feel free to use any DBMS-specific join types.
  
  If you want to add an alias name to the joined table, then you have to
  use the same syntax as for table and column aliases, so let's alias
  the 'posts' table to 'p' in the previous example:
  @code
  cy\DB::select(array('u.id', 'userid')
  		, array('u.name', 'username')
  		, 'p.text')->from(array('users', 'u'))
  		->join(array('posts', 'p'))->on('u.id', '=', 'p.author_fk')->exec();
  @endcode
  
  If you want to select anything that is not a database column but any 
  other database expression, then you have to put it into a @c cy\DB::expr() call.
  Don't mix it up with @c cy\DB::esc() since @c cy\DB::expr() won't perform
  any escaping. Example:
  @code
  cy\DB::select('id')->from('users')
  	->where('created_at', '=', cy\DB::select(cy\DB::expr('max(u.created_at)'))
  		->from(array('users', 'u')))->exec();
  @endcode
  
  The query builder won't care about the contents of your @c cy\DB::expr() call,
  so you can use here whatever complex expression you want.
  
  <em>Note: you can also put your database expression into the @c SELECT
  clause, but in that case you have to pass an alias name using an array.</em>
  
  @subsection db-subqueries Using subqueries
  
  An other thing you could notice in the previous example that we used a 
  subquery in the @c WHERE clause. So just like in SQL, you can use subqueries
  in many places: in the @c SELECT clause, @c FROM clause, @c JOIN clause, etc.
  
  An example to select the count of posts for each users:
  @code
  cy\DB::select('name'
  		, array(cy\DB::select(cy\DB::expr('count(posts.id)')->from('posts')
  			->where('posts.author_fk', '=', 'users.id')
  		), 'post_count')->from('users')->exec();
  @endcode
  
  Note that you don't have to call the @c exec() method of the subquery,
  it will be compiled with its 'parent' query.
  
  @subsection db-sets Using sets
  
  In SQL you can use explicitly defined sets instead of subselects, for 
  example @code SELECT * FROM users WHERE id IN (1, 2, 3) @endcode .
  
  With the DB library you can create such queries by putting an array into 
  a @c cy\DB::expr() call. Example:
  @code
  cy\DB::select()->from('users')->where('id', 'IN', cy\DB::expr(array(1, 2, 3))->exec();
  @endcode

@section db-activerecord The Active Record implementation of the DB library

The DB library contains a lightweight, minimal active record implementation too. In short
and Active Record is "an object that wraps a row in a database table or view,
encapsulates the database access, and adds domain logic on that data" (source:
http://martinfowler.com/eaaCatalog/activeRecord.html ). The active record implementation
in the DB module means a simple abstract class which' subclasses can be easily used
as active record classes in the application. This active record implementation
is meant to be really lightweight since it provides only some simple operations
on the entity, and it doesn't handle connections between tables/entities.

Let's see an example active record class:
@code
namespace app\model;

use cyclone\db\record;

class UserRecord extends record\AbstractRecord {

    protected function setup() {
        // defininig the table name
        $this->_schema->table_name = 'user';
        // defining the table columns
        $this->_schema->columns = array(
            'id' => 'int primary key auto_increment',
            'name' => 'varchar(32) not null',
            'email' => 'varchar(32)'
        );
        // defining hte primary key column
        $this->_schema->primary_key = 'id';
    }

    // boilerplate singleton accessor method
    public static function  inst() {
        return parent::_inst(__CLASS__);
    }

}
@endcode

As it is shown in the above example to create an active record class you have to
extend it from the @c cyclone\db\record\AbstractRecord class and you have to
implement its <code>setup()</code> method. In this method you have to
populate the properties of <code>$this->_schema</code> which is a
@c cyclone\db\record\Schema instance. This object will hold the primitive "mapping"
information which means a table (to be exact: relation) name and a key-value
pair of column names and DDL strings for the column name. The DDL will only be used
by the database schema generator, so if you don't want to take the advantage of
this CLI task then it is easier to omit these DDL fragments and set the array values
to <code>TRUE</code> (or any other value is ok, since the active record itself
will only take into account the array keys in the column list array).
The name of the primary key column is also a mandatory property to be defined (see above).

A boilerplate singleton accessor method should also exist in the active record
classes. Their implementation is always the same (see above). The <code>AbstractRecord</code>
class holds an internal object pool for these singletons (classname => instance)
which are used for operations which doesn't belong to any row already represented
by an existing active record instance.

@subsection db-activerecord-examples Examples of using the above active record

Reading one entity with id #1:
@code
// $user will be an UserRecord instance or NULL if not found
$user = UserRecord::inst()->get(1); @endcode

Creating an entity:
@code
// creating the instance
$user = new UserRecord;

// setting its properties
$user->name = 'hello world';
$user->email = 'helloworld@example.org';

// saving it - since its primary key is unknown it will result in an INSERT statement
// $user->insert() would have the same effect
$user->save(); @endcode

Updating an entity:
@code
$user = UserRecord::inst()->get(1);
$user->email = 'changed@example.com';

// the primary key is already known here since it has been read from the database
// therefore this call will run an UPDATE statement
// $user->update(); would have the same effect
$user->save(); @endcode

Deleting an entity (this method is recommended only if reading the
row is mandatory):
@code
$user = UserModel::inst()->get(1);
$user->delete(); @endcode

Deleting an entity (this method is recommended in most cases, when we just want
to delete the row and we don't need to process it before/after deleting):
@code
UserRecord::inst()->delete(1); @endcode

Reading all entities:
@code
// returns an array of UserRecord instances
$users = UserRecord::inst()->get_all(); @endcode

Reading some entities, filtered by email domain:
@code
use cyclone as cy;
// ...
$example_users = UserRecord::inst()
    ->get_list(array('email', 'LIKE', cy\DB::esc('%example.org'))); @endcode

Reading some entities, filtered and ordered list:
@code
use cyclone as cy;
// ...
$example_users = UserRecord::inst()
    ->get_list(array('email', 'LIKE', cy\DB::esc('%example.org'))
        , array('name', 'desc')); @endcode

Reading one entity but not by its primary key:
@code
use cyclone as cy;
// ...
$user = UserRecord::inst()->get_one(
    array('email', '=', cy\DB::esc('helloworld@example.org'))); @endcode

Reading a "page" (assuming that we want to render the data in a
paginated way):
@code
// second page with 30 items per page
$users = UserRecord::inst()->get_page(2, 30); @endcode

@section db-transactions Transaction handling